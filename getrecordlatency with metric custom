AWSTemplateFormatVersion: "2010-09-09"
Description: >
  Demonstration of a single scale-up alarm and a single scale-down alarm 
  for multi-tier shard scaling using Metric Math (with a 's1' expression for ShardCount)
  directly in CloudFormation. In this version, thresholds are scaled as follows:
    - Latency < 20 ms → 1 shard
    - 20 ms ≤ latency < 40 ms → 2 shards
    - 40 ms ≤ latency < 60 ms → 4 shards
    - 60 ms ≤ latency < 80 ms → 6 shards
    - 80 ms ≤ latency < 100 ms → 8 shards
    - Latency ≥ 100 ms → 10 shards

Parameters:
  StreamName:
    Type: String
    Default: MyDataStream
    Description: "Name of the Kinesis stream to autoscale"

Resources:
  #########################################################
  # Kinesis Stream
  #########################################################
  DataStream:
    Type: AWS::Kinesis::Stream
    Properties:
      Name: !Ref StreamName
      ShardCount: 1

  #########################################################
  # SNS Topic for Alarm Notifications
  #########################################################
  ScalingTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: !Sub "${StreamName}-Scaling"
      TopicName: !Sub "${StreamName}-Scaling"

  #########################################################
  # IAM Role for the Scaling Lambda Function
  #########################################################
  ScalingLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: KinesisScalingPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "kinesis:DescribeStreamSummary"
                  - "kinesis:UpdateShardCount"
                  - "cloudwatch:PutMetricAlarm"
                  - "cloudwatch:SetAlarmState"
                  - "cloudwatch:DescribeAlarms"
                  - "cloudwatch:GetMetricStatistics"
                Resource: "*"

  #########################################################
  # The Scaling Lambda Function
  #########################################################
  ScalingLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${StreamName}-ScalingHandler"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt ScalingLambdaRole.Arn
      Timeout: 60
      Environment:
        Variables:
          STREAM_NAME: !Ref StreamName
          SCALEUP_ALARM_NAME: !Sub "${StreamName}-scale-up"
          SCALEDOWN_ALARM_NAME: !Sub "${StreamName}-scale-down"
      Code:
        ZipFile: |
          import os
          import json
          import time
          import logging
          from datetime import datetime, timedelta
          import boto3
          from botocore.exceptions import ClientError

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          kinesis_client = boto3.client("kinesis")
          cloudwatch_client = boto3.client("cloudwatch")

          STREAM_NAME = os.environ.get("STREAM_NAME")
          SCALEUP_ALARM_NAME = os.environ.get("SCALEUP_ALARM_NAME", f"{STREAM_NAME}-scale-up")
          SCALEDOWN_ALARM_NAME = os.environ.get("SCALEDOWN_ALARM_NAME", f"{STREAM_NAME}-scale-down")

          last_scaled_times = {}

          def decide_shard_count(latency):
              if latency < 20:
                  return 1
              elif latency < 40:
                  return 2
              elif latency < 60:
                  return 4
              elif latency < 80:
                  return 6
              elif latency < 100:
                  return 8
              else:
                  return 10

          NEXT_SCALEUP_THRESHOLD = {
              1:  20,
              2:  40,
              4:  60,
              6:  80,
              8:  100,
              10: 999999
          }

          NEXT_SCALEDOWN_THRESHOLD = {
              1:  0,
              2:  20,
              4:  40,
              6:  60,
              8:  80,
              10: 100
          }

          def parse_alarm_event(event):
              sns_record = event["Records"][0]["Sns"]
              alarm_message = sns_record.get("Message", "{}")
              alarm_data = json.loads(alarm_message)
              return {
                  "AlarmName": alarm_data.get("AlarmName", ""),
                  "NewStateValue": alarm_data.get("NewStateValue", "UNKNOWN"),
              }

          def get_latency():
              now = datetime.utcnow()
              start = now - timedelta(minutes=5)
              resp = cloudwatch_client.get_metric_statistics(
                  Namespace="AWS/Kinesis",
                  MetricName="GetRecords.Latency",
                  Dimensions=[{"Name": "StreamName", "Value": STREAM_NAME}],
                  StartTime=start,
                  EndTime=now,
                  Period=300,
                  Statistics=["Average"]
              )
              dps = resp.get("Datapoints", [])
              if not dps:
                  return 0.0
              latest = sorted(dps, key=lambda x: x["Timestamp"])[-1]
              return latest["Average"]

          def get_current_shard_count():
              resp = kinesis_client.describe_stream_summary(StreamName=STREAM_NAME)
              return resp["StreamDescriptionSummary"]["OpenShardCount"]

          def scale_shards(desired):
              current = get_current_shard_count()
              if desired == current:
                  logger.info("No scaling needed. Already at %d shards.", current)
                  return
              if desired > current * 2:
                  desired = current * 2
              elif desired < max(1, current // 2):
                  desired = max(1, current // 2)
              if desired == current:
                  logger.info("After constraints, no scale change.")
                  return
              logger.info(f"Scaling {STREAM_NAME} from {current} to {desired} shards.")
              kinesis_client.update_shard_count(
                  StreamName=STREAM_NAME,
                  TargetShardCount=desired,
                  ScalingType="UNIFORM_SCALING"
              )
              last_scaled_times[STREAM_NAME] = time.time()

          def update_alarm_threshold(alarm_name, threshold, comparison):
              logger.info(f"Updating alarm {alarm_name} to threshold={threshold} ms, operator={comparison}.")
              metrics = [
                  {
                      "Id": "s1",
                      "Expression": "1",  # For demonstration, this is a constant. You can set this dynamically.
                      "Label": "ShardCount",
                      "ReturnData": False
                  },
                  {
                      "Id": "m1",
                      "MetricStat": {
                          "Metric": {
                              "Namespace": "AWS/Kinesis",
                              "MetricName": "GetRecords.Latency",
                              "Dimensions": [
                                  {"Name": "StreamName", "Value": STREAM_NAME}
                              ]
                          },
                          "Period": 300,
                          "Stat": "Average"
                      },
                      "ReturnData": True
                  }
              ]
              cloudwatch_client.put_metric_alarm(
                  AlarmName=alarm_name,
                  AlarmDescription="Alarm dynamically updated to next threshold",
                  ComparisonOperator=comparison,
                  EvaluationPeriods=3,
                  Threshold=threshold,
                  Metrics=metrics,
                  TreatMissingData="ignore",
                  AlarmActions=[]
              )
              cloudwatch_client.set_alarm_state(
                  AlarmName=alarm_name,
                  StateValue="INSUFFICIENT_DATA",
                  StateReason="Reconfigured threshold after scaling"
              )

          def lambda_handler(event, context):
              logger.info("Event: %s", json.dumps(event))
              alarm_info = parse_alarm_event(event)
              alarm_name = alarm_info["AlarmName"]
              new_state = alarm_info["NewStateValue"]

              logger.info(f"Alarm={alarm_name}, newState={new_state}")
              if new_state != "ALARM":
                  logger.info("Not in ALARM state. Exiting.")
                  return

              latency = get_latency()
              desired = decide_shard_count(latency)
              logger.info(f"Measured latency: {latency:.0f} ms => desired shards: {desired}")

              scale_shards(desired)
              current_shards = get_current_shard_count()

              if alarm_name.endswith("-scale-up"):
                  next_up_thresh = NEXT_SCALEUP_THRESHOLD.get(current_shards, 999999)
                  next_down_thresh = NEXT_SCALEDOWN_THRESHOLD.get(current_shards, 0)
                  update_alarm_threshold(SCALEUP_ALARM_NAME, next_up_thresh, "GreaterThanThreshold")
                  update_alarm_threshold(SCALEDOWN_ALARM_NAME, next_down_thresh, "LessThanThreshold")
              elif alarm_name.endswith("-scale-down"):
                  next_up_thresh = NEXT_SCALEUP_THRESHOLD.get(current_shards, 999999)
                  next_down_thresh = NEXT_SCALEDOWN_THRESHOLD.get(current_shards, 0)
                  update_alarm_threshold(SCALEUP_ALARM_NAME, next_up_thresh, "GreaterThanThreshold")
                  update_alarm_threshold(SCALEDOWN_ALARM_NAME, next_down_thresh, "LessThanThreshold")
              else:
                  logger.warning("Alarm name doesn't match -scale-up or -scale-down suffix. No reconfiguration done.")
              logger.info("Done scaling logic.")

  #########################################################
  # SNS Subscription -> Lambda
  #########################################################
  ScalingSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref ScalingTopic
      Protocol: "lambda"
      Endpoint: !GetAtt ScalingLambdaFunction.Arn

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ScalingLambdaFunction
      Action: "lambda:InvokeFunction"
      Principal: "sns.amazonaws.com"
      SourceArn: !Ref ScalingTopic

  #########################################################
  # Single Scale-Up Alarm (initial threshold=20)
  #########################################################
  ScaleUpAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${StreamName}-scale-up"
      AlarmDescription: "Initial scale-up alarm for latency > 20ms"
      Metrics:
        - Id: s1
          Expression: "1"
          Label: "ShardCount"
          ReturnData: False
        - Id: m1
          MetricStat:
            Metric:
              Namespace: "AWS/Kinesis"
              MetricName: "GetRecords.Latency"
              Dimensions:
                - Name: "StreamName"
                  Value: !Ref DataStream
            Period: 300
            Stat: "Average"
          ReturnData: True
      EvaluationPeriods: 3
      Threshold: 20
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !Ref ScalingTopic
      TreatMissingData: "ignore"

  #########################################################
  # Single Scale-Down Alarm (initial threshold=20)
  #########################################################
  ScaleDownAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${StreamName}-scale-down"
      AlarmDescription: "Initial scale-down alarm for latency < 20ms"
      Metrics:
        - Id: s1
          Expression: "1"
          Label: "ShardCount"
          ReturnData: False
        - Id: m1
          MetricStat:
            Metric:
              Namespace: "AWS/Kinesis"
              MetricName: "GetRecords.Latency"
              Dimensions:
                - Name: "StreamName"
                  Value: !Ref DataStream
            Period: 300
            Stat: "Average"
          ReturnData: True
      EvaluationPeriods: 3
      Threshold: 20
      ComparisonOperator: LessThanThreshold
      AlarmActions:
        - !Ref ScalingTopic
      TreatMissingData: "ignore"

Outputs:
  DataStreamName:
    Description: "Name of the Kinesis Data Stream"
    Value: !Ref DataStream

  ScaleUpAlarmName:
    Description: "Name of the scale-up alarm"
    Value: !Ref ScaleUpAlarm

  ScaleDownAlarmName:
    Description: "Name of the scale-down alarm"
    Value: !Ref ScaleDownAlarm

  ScalingLambdaFunctionName:
    Description: "Name of the scaling Lambda function"
    Value: !Ref ScalingLambdaFunction
