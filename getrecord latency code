AWSTemplateFormatVersion: '2010-09-09'
Description: |
  Demonstration of a single scale-up alarm and a single scale-down alarm  for multi-tier shard scaling, injecting 's1' for ShardCount in Metric Math, and avoiding CloudFormation's "AlarmName must be read-only" error  by referencing the alarm with !Ref in Outputs.

Parameters:
  StreamName:
    Type: String
    Default: MyDataStream
    Description: Name of the Kinesis stream to autoscale

Resources:
  #########################################################
  # Kinesis Stream
  #########################################################
  DataStream:
    Type: AWS::Kinesis::Stream
    Properties:
      Name: !Ref StreamName
      ShardCount: 1

  #########################################################
  # SNS Topic for Alarm Notifications
  #########################################################
  ScalingTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: !Sub ${StreamName}-Scaling
      TopicName: !Sub ${StreamName}-Scaling

  #########################################################
  # IAM Role for the Lambda Function
  #########################################################
  ScalingLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: KinesisScalingPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - kinesis:DescribeStreamSummary
                  - kinesis:UpdateShardCount
                  - cloudwatch:PutMetricAlarm
                  - cloudwatch:SetAlarmState
                  - cloudwatch:DescribeAlarms
                  - cloudwatch:GetMetricStatistics
                Resource: '*'

  #########################################################
  # The Scaling Lambda
  #########################################################
  ScalingLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${StreamName}-ScalingHandler
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt ScalingLambdaRole.Arn
      Timeout: 60
      Environment:
        Variables:
          STREAM_NAME: !Ref StreamName
          SCALEUP_ALARM_NAME: !Sub ${StreamName}-scale-up
          SCALEDOWN_ALARM_NAME: !Sub ${StreamName}-scale-down
      Code:
        ZipFile: |
          import os
          import json
          import time
          import logging
          from datetime import datetime, timedelta
          import boto3
          from botocore.exceptions import ClientError

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          kinesis_client = boto3.client("kinesis")
          cloudwatch_client = boto3.client("cloudwatch")

          STREAM_NAME = os.environ.get("STREAM_NAME")
          SCALEUP_ALARM_NAME = os.environ.get("SCALEUP_ALARM_NAME", f"{STREAM_NAME}-scale-up")
          SCALEDOWN_ALARM_NAME = os.environ.get("SCALEDOWN_ALARM_NAME", f"{STREAM_NAME}-scale-down")

          # In-memory cooldown tracking
          last_scaled_times = {}

          # We'll define 6 ranges for latency:
          # <200 => 1 shard
          # 200-399 => 2 shards
          # 400-599 => 4 shards
          # 600-799 => 6 shards
          # 800-999 => 8 shards
          # >=1000 => 10 shards
          def decide_shard_count(latency):
              if latency < 200:
                  return 1
              elif latency < 400:
                  return 2
              elif latency < 600:
                  return 4
              elif latency < 800:
                  return 6
              elif latency < 1000:
                  return 8
              else:
                  return 10

          # Next threshold for scale-up given a new shard count
          NEXT_SCALEUP_THRESHOLD = {
              1:  200,
              2:  400,
              4:  600,
              6:  800,
              8:  1000,
              10: 999999  # no further scale-up
          }

          # Next threshold for scale-down
          NEXT_SCALEDOWN_THRESHOLD = {
              1:  0,    # can't go below 1
              2:  200,
              4:  400,
              6:  600,
              8:  800,
              10: 1000
          }

          def parse_alarm_event(event):
              sns_record = event["Records"][0]["Sns"]
              alarm_message = sns_record.get("Message", "{}")
              alarm_data = json.loads(alarm_message)
              return {
                  "AlarmName": alarm_data.get("AlarmName", ""),
                  "NewStateValue": alarm_data.get("NewStateValue", "UNKNOWN"),
              }

          def get_latency():
              now = datetime.utcnow()
              start = now - timedelta(minutes=5)
              resp = cloudwatch_client.get_metric_statistics(
                  Namespace="AWS/Kinesis",
                  MetricName="GetRecords.Latency",
                  Dimensions=[{"Name":"StreamName","Value":STREAM_NAME}],
                  StartTime=start,
                  EndTime=now,
                  Period=300,
                  Statistics=["Average"]
              )
              dps = resp.get("Datapoints", [])
              if not dps:
                  return 0.0
              latest = sorted(dps, key=lambda x: x["Timestamp"])[-1]
              return latest["Average"]

          def get_current_shard_count():
              resp = kinesis_client.describe_stream_summary(StreamName=STREAM_NAME)
              return resp["StreamDescriptionSummary"]["OpenShardCount"]

          def scale_shards(desired):
              current = get_current_shard_count()
              if desired == current:
                  logger.info("No scaling needed. Already at %d shards.", current)
                  return
              # respect Kinesis constraints
              if desired > current * 2:
                  desired = current * 2
              elif desired < max(1, current // 2):
                  desired = max(1, current // 2)

              if desired == current:
                  logger.info("After constraint check, no scale change.")
                  return

              logger.info(f"Scaling {STREAM_NAME} from {current} to {desired} shards.")
              kinesis_client.update_shard_count(
                  StreamName=STREAM_NAME,
                  TargetShardCount=desired,
                  ScalingType="UNIFORM_SCALING"
              )
              last_scaled_times[STREAM_NAME] = time.time()

          def update_alarm_threshold(alarm_name, threshold, comparison):
              """
              PutMetricAlarm with a 'ShardCount' expression (s1).
              We'll keep the same period, evaluation periods, etc.
              but override the 'Metrics' array to embed s1, m1, etc.

              We do NOT overwrite AlarmActions here for simplicity.
              If you need them, you must retrieve them first or store them.
              """
              logger.info(f"Updating alarm {alarm_name} -> threshold={threshold}, op={comparison}")
              # For demonstration, define a simple metrics array:
              # s1 => shardcount as an expression (just a placeholder '1' here).
              # m1 => the actual Kinesis Latency metric
              metrics = [
                  {
                      "Id": "s1",
                      "Expression": "1",  # Replace with str(current_shard_count) if desired
                      "Label": "ShardCount",
                      "ReturnData": False
                  },
                  {
                      "Id": "m1",
                      "MetricStat": {
                          "Metric": {
                              "Namespace": "AWS/Kinesis",
                              "MetricName": "GetRecords.Latency",
                              "Dimensions": [
                                  {"Name":"StreamName","Value": STREAM_NAME}
                              ]
                          },
                          "Period": 300,
                          "Stat": "Average"
                      },
                      "ReturnData": True
                  }
              ]

              cloudwatch_client.put_metric_alarm(
                  AlarmName=alarm_name,
                  AlarmDescription="Alarm dynamically updated to next threshold",
                  ComparisonOperator=comparison,
                  EvaluationPeriods=3,
                  Threshold=threshold,
                  Metrics=metrics,
                  TreatMissingData="ignore",
                  AlarmActions=[]  # If you want the old SNS action, you'd retrieve it from DescribeAlarms
              )

              # Optionally set alarm to INSUFFICIENT_DATA
              cloudwatch_client.set_alarm_state(
                  AlarmName=alarm_name,
                  StateValue="INSUFFICIENT_DATA",
                  StateReason="Updating alarm metric definitions"
              )

          def lambda_handler(event, context):
              logger.info("Event: %s", json.dumps(event))
              alarm_info = parse_alarm_event(event)
              alarm_name = alarm_info["AlarmName"]
              new_state = alarm_info["NewStateValue"]

              logger.info(f"Alarm={alarm_name}, newState={new_state}")
              if new_state != "ALARM":
                  logger.info("Not in ALARM state. Exiting.")
                  return

              # measure latency
              latency = get_latency()
              desired = decide_shard_count(latency)
              logger.info(f"Latency={latency:.0f} ms => desiredShards={desired}")

              scale_shards(desired)

              current_shards = get_current_shard_count()

              if alarm_name.endswith("-scale-up"):
                  # we just scaled up
                  next_up_thresh = NEXT_SCALEUP_THRESHOLD.get(current_shards, 999999)
                  next_down_thresh = NEXT_SCALEDOWN_THRESHOLD.get(current_shards, 0)

                  update_alarm_threshold(SCALEUP_ALARM_NAME, next_up_thresh, "GreaterThanThreshold")
                  update_alarm_threshold(SCALEDOWN_ALARM_NAME, next_down_thresh, "LessThanThreshold")

              elif alarm_name.endswith("-scale-down"):
                  # scaled down
                  next_up_thresh = NEXT_SCALEUP_THRESHOLD.get(current_shards, 999999)
                  next_down_thresh = NEXT_SCALEDOWN_THRESHOLD.get(current_shards, 0)

                  update_alarm_threshold(SCALEUP_ALARM_NAME, next_up_thresh, "GreaterThanThreshold")
                  update_alarm_threshold(SCALEDOWN_ALARM_NAME, next_down_thresh, "LessThanThreshold")
              else:
                  logger.warning("Alarm name doesn't match -scale-up or -scale-down suffix. No reconfig.")
              logger.info("Done scaling logic.")

  #########################################################
  # SNS Subscription -> Lambda
  #########################################################
  ScalingSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref ScalingTopic
      Protocol: lambda
      Endpoint: !GetAtt ScalingLambdaFunction.Arn

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ScalingLambdaFunction
      Action: lambda:InvokeFunction
      Principal: sns.amazonaws.com
      SourceArn: !Ref ScalingTopic

  #########################################################
  # Single Scale-Up Alarm (initial threshold=200)
  # Must specify AlarmName so !Ref returns that name
  #########################################################
  ScaleUpAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ${StreamName}-scale-up
      AlarmDescription: Initial scale-up alarm for latency > 200ms
      Namespace: AWS/Kinesis
      MetricName: GetRecords.Latency
      Dimensions:
        - Name: StreamName
          Value: !Ref DataStream
      Statistic: Average
      Period: 300
      EvaluationPeriods: 3
      Threshold: 200
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !Ref ScalingTopic
      TreatMissingData: ignore

  #########################################################
  # Single Scale-Down Alarm (initial threshold=200)
  #########################################################
  ScaleDownAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ${StreamName}-scale-down
      AlarmDescription: Initial scale-down alarm for latency < 200ms
      Namespace: AWS/Kinesis
      MetricName: GetRecords.Latency
      Dimensions:
        - Name: StreamName
          Value: !Ref DataStream
      Statistic: Average
      Period: 300
      EvaluationPeriods: 3
      Threshold: 200
      ComparisonOperator: LessThanThreshold
      AlarmActions:
        - !Ref ScalingTopic
      TreatMissingData: ignore

Outputs:
  DataStreamName:
    Description: Name of the Kinesis Data Stream
    Value: !Ref DataStream

  ScaleUpAlarmName:
    Description: Name of the scale-up alarm
    Value: !Ref ScaleUpAlarm

  ScaleDownAlarmName:
    Description: Name of the scale-down alarm
    Value: !Ref ScaleDownAlarm

  ScalingLambdaFunctionName:
    Description: Name of the scaling Lambda function
    Value: !Ref ScalingLambdaFunction
